// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// generator client {
//   provider = "prisma-client-js"
// }

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
}

enum UserRole {
  USER
  ADMIN
}

model User {
  id                    String                 @id @default(cuid())
  name                  String?
  email                 String?                @unique
  emailVerified         DateTime?
  image                 String?
  password              String?
  confirmPassword       String?
  role                  UserRole               @default(USER)
  accounts              Account[]
  courses               Course[]
  isTwoFactorEnabled    Boolean                @default(false)
  twoFactorConfirmation TwoFactorConfirmation?

  phone        String? // Optional field for phone number
  profileLinks ProfileLink[] // One-to-many relation with ProfileLink

  posts    Post[]    // One-to-many relation with Post
  comments Comment[] // One-to-many relation with Comment
  replies  Reply[]   // One-to-many relation with Reply
  reactions Reaction[] // One-to-many relation with Reaction

  // Relations to learning resources created by the user
  videos   Video[]   @relation("UserVideos")
  blogs    Blog[]    @relation("UserBlogs")
  articles Article[] @relation("UserArticles")
  notes    Note[]    @relation("UserNotes")

  // Relations to favorite content
  favoriteVideos   FavoriteVideo[] // One-to-many relation with FavoriteVideo
  favoriteAudios   FavoriteAudio[] // One-to-many relation with FavoriteAudio
  favoriteArticles FavoriteArticle[] // One-to-many relation with FavoriteArticle
  favoriteBlogs    FavoriteBlog[] // One-to-many relation with FavoriteBlog
  favoriteImages   FavoriteImage[] // One-to-many relation with FavoriteImage
  subscriptions    Subscription[]
  calendarEvents   CalendarEvent[]
  supportTickets   SupportTicket[]

  // Add these relations
  ideas           Idea[]
  ideaLikes       IdeaLike[]
  ideaComments    IdeaComment[]
  collaboratingOn Idea[]        @relation("IdeaCollaborators")

  // Add these models to your schema
  minds              Mind[]
  mindLikes          MindLike[]
  collaboratingMinds Mind[]     @relation("MindCollaborators")

  bills       Bill[]
  enrollments Enrollment[]
  examAttempts ExamAttempt[]   // Add relation to exam attempts

  // Add calendar settings relation
  calendarSettings UserCalendarSettings?

  // Add these relation fields
  createdGroups      Group[]                  @relation("GroupCreator")
  groupMemberships   GroupMember[]
  groupDiscussions   GroupDiscussion[]        @relation("AuthoredDiscussions")
  discussionLikes    GroupDiscussionLike[]    @relation("UserLikes")
  discussionComments GroupDiscussionComment[] @relation("AuthoredComments")
  createdEvents      GroupEvent[]             @relation("EventCreator")
  organizedEvents    GroupEvent[]             @relation("OrganizedEvents")
  eventAttendees     GroupEventAttendee[]     @relation("EventAttendee")

  // Add these models for notifications and search
  groupNotifications GroupNotification[]
  sharedResources    GroupResource[]     @relation("AuthoredResources")

  customTabs CustomTab[] // Relation field

  reviews CourseReview[]

  createdAt DateTime @default(now())

  // Add these new relations
  notifications    Notification[]
  sentMessages     Message[]      @relation("SentMessages")
  receivedMessages Message[]      @relation("ReceivedMessages")
  activities       Activity[]     // Relation to activities

  // Add these relations
  authAudits      AuthAudit[]
  activeSessions  ActiveSession[]
  backupCodes     BackupCode[]
  totpSecret      TOTPSecret?

  tasks         Task[]        // Add relation for tasks
}

model Course {
  id          String    @id @default(uuid())
  title       String    @db.Text
  description String?   // HTML version
  cleanDescription String? // Clean text version
  imageUrl    String?   @db.Text
  price       Float?
  isPublished Boolean   @default(false)
  courseGoals String?
  categoryId  String?
  category    Category? @relation(fields: [categoryId], references: [id])

  courseRatings  String?
  activeLearners Int?

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  chapters    Chapter[]
  attachments Attachment[]
  purchases   Purchase[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reviews     CourseReview[]
  enrollments Enrollment[]
  whatYouWillLearn String[] @default([])

  groups Group[]

  @@index([categoryId])
}

model Chapter {
  id               String  @id @default(uuid())
  title            String
  description      String? @db.Text
  courseGoals      String? @db.Text
  learningOutcomes String? @db.Text
  position         Int
  isPublished      Boolean @default(false)
  isFree           Boolean @default(false)
  sectionCount     Int?
  totalDuration    Int?
  courseId         String
  course           Course  @relation(fields: [courseId], references: [id], onDelete: Cascade)

  userProgress UserProgress[]
  sections     Section[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  estimatedTime String?
  difficulty    String?
  prerequisites String?
  resources     String?
  status        String?

  @@index([courseId])
}

model Section {
  id          String  @id @default(uuid())
  title       String
  videoUrl    String? @db.Text
  position    Int
  isPublished Boolean @default(false)
  isFree      Boolean @default(false)
  duration    Int?
  chapterId   String
  chapter     Chapter @relation(fields: [chapterId], references: [id], onDelete: Cascade)

  userProgress UserProgress[]
  questions    Question[]

  // Relations to various resources within this section
  videos           Video[] // One-to-many relation with Video
  blogs            Blog[] // One-to-many relation with Blog
  articles         Article[] // One-to-many relation with Article
  notes            Note[] // One-to-many relation with Note
  codeExplanations CodeExplanation[]
  mathExplanations MathExplanation[] // One-to-many relation with MathExplanation
  exams            Exam[] // One-to-many relation with Exam

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  type             String?
  isPreview        Boolean?
  completionStatus String?
  resourceUrls     String?

  @@index([chapterId])
}

// Add CodeExplanation model
model CodeExplanation {
  id          String   @id @default(cuid())
  heading     String?
  code        String?  @db.Text
  explanation String?  @db.Text
  language    String?  @default("typescript")
  order       Int?     @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  sectionId String?
  section   Section? @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  @@index([sectionId])
}

// MathExplanation model for mathematical content and explanations
model MathExplanation {
  id          String  @id @default(uuid())
  title       String
  content     String  @db.Text
  latex       String? @db.Text
  equation    String? @db.Text // LaTeX equation string
  imageUrl    String? @db.Text // Image URL for visual mode
  mode        String? // "equation" or "visual"
  isPublished Boolean @default(false)
  
  sectionId   String
  section     Section @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([sectionId])
}

// Exam model for assessments and tests
model Exam {
  id          String  @id @default(uuid())
  title       String
  description String? @db.Text
  duration    Int? // Duration in minutes
  isPublished Boolean @default(false)
  isTimeLimited Boolean @default(false)
  
  sectionId   String
  section     Section @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  
  questions   ExamQuestion[]
  attempts    ExamAttempt[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([sectionId])
}

// ExamQuestion model for questions within an exam
model ExamQuestion {
  id          String  @id @default(uuid())
  question    String  @db.Text
  options     Json? // Array of possible answers
  correctAnswer String? @db.Text
  points      Int     @default(1)
  questionType String  @default("MULTIPLE_CHOICE") // MULTIPLE_CHOICE, TRUE_FALSE, SHORT_ANSWER, ESSAY
  
  examId      String
  exam        Exam    @relation(fields: [examId], references: [id], onDelete: Cascade)
  
  answers     ExamAnswer[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([examId])
}

// ExamAttempt model to track user attempts at exams
model ExamAttempt {
  id          String  @id @default(uuid())
  examId      String
  exam        Exam    @relation(fields: [examId], references: [id], onDelete: Cascade)
  userId      String
  user        User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  startedAt   DateTime @default(now())
  completedAt DateTime?
  score       Float?
  
  answers     ExamAnswer[]
  
  @@index([examId])
  @@index([userId])
}

// ExamAnswer model to store user answers to exam questions
model ExamAnswer {
  id          String  @id @default(uuid())
  answer      String  @db.Text
  isCorrect   Boolean?
  
  questionId  String
  question    ExamQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  
  attemptId   String
  attempt     ExamAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  
  @@index([questionId])
  @@index([attemptId])
}

model Video {
  id            String   @id @default(cuid())
  title         String
  description   String?  @db.Text
  youtubeUrl    String?  @db.Text
  url           String?  @db.Text
  duration      Int?
  rating        Int?     // Changed to match the blog model pattern
  position      Int
  isPublished   Boolean  @default(false)
  sectionId     String
  section       Section  @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // New fields
  thumbnail     String?  @db.Text
  platform      String?
  embedUrl      String?  @db.Text
  author        String?

  userId String
  user   User   @relation("UserVideos", fields: [userId], references: [id], onDelete: Cascade)

  @@index([sectionId])
  @@index([userId])
}

model Blog {
  id          String    @id @default(cuid())
  title       String
  url         String    @db.VarChar(255)
  author      String?
  description String?   @db.Text
  rating      Int?      // Add this field
  publishedAt DateTime?
  position    Int?
  sectionId   String?
  section     Section?  @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation("UserBlogs", fields: [userId], references: [id], onDelete: Cascade)

  category String?

  isPublished Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Article {
  id          String    @id @default(cuid())
  title       String
  content     String    @db.Text
  url         String    @db.VarChar(255)
  source      String? // Source of the article (e.g., Medium, New York Times)
  summary     String?   @db.Text
  publishedAt DateTime?

  sectionId String?
  section   Section? @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation("UserArticles", fields: [userId], references: [id], onDelete: Cascade)

  category String?

  isPublished Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Note {
  id          String  @id @default(uuid())
  title       String
  content     String  @db.Text
  isImportant Boolean @default(false) // Flag to mark important notes
  position    Int // Position within a section if ordered

  sectionId String?
  section   Section? @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation("UserNotes", fields: [userId], references: [id], onDelete: Cascade)

  category String?

  isPublished Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model ProfileLink {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  platform  String // Name of the social media platform (e.g., "Twitter", "Facebook")
  url       String // URL of the social media profile
  position  Int?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model VerificationToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorConfirmation {
  id String @id @default(cuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
}

model Category {
  id      String   @id @default(cuid())
  name    String   @unique
  courses Course[]
  groups  Group[]  // Keep the groups relation
}

model Attachment {
  id   String @id @default(uuid())
  name String
  url  String @db.Text

  courseId String
  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([courseId])
}

model Question {
  id   String @id @default(uuid())
  text String @db.Text

  answers   Answer[]
  sectionId String?
  section   Section? @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Answer {
  id         String   @id @default(uuid())
  text       String   @db.Text
  isCorrect  Boolean  @default(false)
  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserProgress {
  id     String @id @default(uuid())
  userId String

  chapterId String
  chapter   Chapter @relation(fields: [chapterId], references: [id], onDelete: Cascade)

  sectionId String  @unique
  section   Section @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  isCompleted Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, chapterId])
  @@index([chapterId])
}

model Purchase {
  id     String @id @default(uuid())
  userId String

  courseId String
  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  @@unique([userId, courseId])
  @@index([courseId])
}

model StripeCustomer {
  id               String @id @default(uuid())
  userId           String @unique
  stripeCustomerId String @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Post {
  id          String   @id @default(cuid())
  title       String
  description String?  @db.Text
  imageUrl    String?  @db.Text
  category    String?  // Keep this field
  published   Boolean? // Keep this field
  views       Int      @default(0) // Add views field
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  postchapter PostChapterSection[]
  postimage   PostImageSection[]
  comments    Comment[]
  replies     Reply[]
  tags        Tag[]

  @@index([userId])
}

model PostChapterSection {
  id          String   @id @default(cuid())
  title       String
  content     String?  @db.Text
  description String?  @db.Text    // Keep this field
  imageUrl    String?  @db.Text    // Keep this field
  isFree      Boolean? @default(false) // Keep this field
  isPublished Boolean? @default(false) // Keep this field
  position    Int
  postId      String
  post        Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([postId])
}

model Comment {
  id        String   @id @default(cuid())
  content   String   @db.Text
  userId    String
  postId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  post    Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  replies Reply[]
  reactions Reaction[] @relation("CommentReactions")

  @@index([userId])
  @@index([postId])
}

model Reply {
  id        String   @id @default(cuid())
  content   String   @db.Text
  userId    String
  postId    String
  commentId String
  parentReplyId String?
  depth     Int      @default(0) // Track nesting level - 0 means direct reply to comment
  path      String?  // Store the full path for efficient lookups e.g. "comment_id/reply1_id/reply2_id"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  post    Post    @relation(fields: [postId], references: [id], onDelete: Cascade)
  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  parentReply Reply? @relation("ReplyToReply", fields: [parentReplyId], references: [id], onDelete: SetNull)
  childReplies Reply[] @relation("ReplyToReply")
  reactions Reaction[] @relation("ReplyReactions")

  @@index([userId])
  @@index([postId])
  @@index([commentId])
  @@index([parentReplyId])
  @@index([path]) // Index the path for efficient hierarchical queries
}

model Reaction {
  id        String   @id @default(cuid())
  type      String
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment   Comment? @relation("CommentReactions", fields: [commentId], references: [id], onDelete: Cascade)
  commentId String?
  reply     Reply?   @relation("ReplyReactions", fields: [replyId], references: [id], onDelete: Cascade)
  replyId   String?

  @@index([userId])
  @@index([commentId])
  @@index([replyId])
}

model PostImageSection {
  id        String   @id @default(cuid())
  imageUrl  String   @db.Text
  position  Int
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId])
}

model Tag {
  id    String @id @default(cuid())
  name  String @unique
  posts Post[]
}

model FavoriteVideo {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  title     String // Title of the favorite video
  platform  String // Platform name (e.g., "YouTube", "Vimeo")
  url       String // URL of the video
  position  Int?
  category  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FavoriteAudio {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  title     String // Title of the favorite audio
  platform  String // Platform name (e.g., "Spotify", "SoundCloud")
  url       String // URL of the audio
  position  Int?
  category  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FavoriteArticle {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  title     String // Title of the favorite article
  platform  String // Platform name (e.g., "Medium", "NYTimes")
  url       String // URL of the article
  position  Int?
  category  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FavoriteBlog {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  title     String // Title of the favorite blog
  platform  String // Platform name (e.g., "WordPress", "Blogger")
  url       String // URL of the blog
  position  Int?
  category  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FavoriteImage {
  id        String   @id @default(cuid())
  userId    String
  imageUrl  String
  title     String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Subscription {
  id                   String    @id @default(cuid())
  userId               String
  stripeCustomerId     String?   @map(name: "stripe_customer_id")
  stripeSubscriptionId String?   @map(name: "stripe_subscription_id")
  stripePriceId       String?    @map(name: "stripe_price_id")
  stripeCurrentPeriodEnd DateTime? @map(name: "stripe_current_period_end")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
}

// Calendar Event model for task planning and scheduling
model CalendarEvent {
  id              String    @id @default(cuid())
  title           String
  description     String?   @db.Text
  startDate       DateTime
  endDate         DateTime
  allDay          Boolean   @default(false)
  category        String
  location        String?
  recurringType   String?   // "none", "daily", "weekly", "monthly", "yearly"
  recurringEndDate DateTime?
  color           String?
  taskId          String?   // Optional link to a task
  
  // User who owns this event
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Optional relation to parent event for recurring series
  parentEventId   String?
  parentEvent     CalendarEvent?  @relation("RecurringSeries", fields: [parentEventId], references: [id], onDelete: SetNull)
  childEvents     CalendarEvent[] @relation("RecurringSeries")
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // External calendar fields
  externalId      String?
  source          String?
  lastSync        DateTime?
  
  @@unique([externalId, source])
  @@index([userId])
  @@index([startDate])
  @@index([parentEventId])
}

model SupportTicket {
  id        String   @id @default(cuid())
  subject   String
  category  String
  message   String   @db.Text
  status    String   @default("OPEN") // OPEN, IN_PROGRESS, CLOSED
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model Idea {
  id            String   @id @default(cuid())
  title         String
  description   String?  @db.Text
  category      String
  visibility    String // "public" | "private" | "collaborative"
  status        String // "draft" | "published" | "archived"
  tags          String[] // Array of tags
  likes         Int      @default(0)
  comments      Int      @default(0)
  collaborators Int      @default(0)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Relations
  ideaLikes         IdeaLike[]
  ideaComments      IdeaComment[]
  collaboratorUsers User[]        @relation("IdeaCollaborators")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model IdeaLike {
  id        String   @id @default(cuid())
  ideaId    String
  userId    String
  idea      Idea     @relation(fields: [ideaId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([ideaId, userId])
  @@index([ideaId])
  @@index([userId])
}

model IdeaComment {
  id        String   @id @default(cuid())
  content   String   @db.Text
  ideaId    String
  userId    String
  idea      Idea     @relation(fields: [ideaId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ideaId])
  @@index([userId])
}

model Mind {
  id          String   @id @default(cuid())
  title       String
  description String?  @db.Text
  content     Json // For storing mind map structure
  category    String
  visibility  String // "public" | "private" | "collaborative"
  status      String // "draft" | "published" | "archived"
  tags        String[]
  likes       Int      @default(0)
  views       Int      @default(0)
  shares      Int      @default(0)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Relations
  mindLikes     MindLike[]
  collaborators User[]     @relation("MindCollaborators")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model MindLike {
  id        String   @id @default(cuid())
  mindId    String
  userId    String
  mind      Mind     @relation(fields: [mindId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([mindId, userId])
  @@index([mindId])
  @@index([userId])
}

model Bill {
  id              String         @id @default(cuid())
  title           String
  description     String?        @db.Text
  category        BillCategory
  amount          Float
  currency        String         @default("USD")
  startDate       DateTime
  dueDate         DateTime
  status          BillStatus     @default(UNPAID)
  recurringType   RecurringType? // For recurring bills
  recurringPeriod Int? // Period in days for recurring bills

  // Notification settings
  notifyBefore Int     @default(3) // Days before due date
  notifyEmail  Boolean @default(true)
  notifySMS    Boolean @default(false)

  // Payment tracking
  lastPaidAmount Float?
  lastPaidDate   DateTime?
  autoPayEnabled Boolean   @default(false)
  paymentMethod  String? // e.g., "Credit Card", "Bank Transfer"
  accountNumber  String? // Last 4 digits of payment account

  // Bill provider details
  provider       String?
  accountId      String? // Account ID with provider
  website        String? // Provider's website
  supportContact String? // Provider's support contact

  // Attachments and notes
  attachments BillAttachment[]
  notes       String?          @db.Text

  // User relation
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // History and timestamps
  paymentHistory BillPayment[]
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@index([userId])
  @@index([dueDate]) // For efficient due date queries
}

model BillAttachment {
  id        String   @id @default(cuid())
  name      String
  url       String
  type      String // e.g., "invoice", "receipt", "statement"
  size      Int // File size in bytes
  billId    String
  bill      Bill     @relation(fields: [billId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@index([billId])
}

model BillPayment {
  id          String   @id @default(cuid())
  amount      Float
  paymentDate DateTime
  method      String // e.g., "Credit Card", "Bank Transfer"
  status      String // e.g., "successful", "pending", "failed"
  reference   String? // Payment reference number
  billId      String
  bill        Bill     @relation(fields: [billId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())

  @@index([billId])
}

enum BillCategory {
  UTILITY // Energy, Water, Gas
  INTERNET // Internet, Phone, Cable
  INSURANCE // Health, Car, Home, Life
  RENT // Housing rent
  MORTGAGE // Home loan
  SUBSCRIPTION // Software, Streaming, etc.
  TAX // Property tax, etc.
  CREDIT_CARD // Credit card bills
  OTHER // Miscellaneous
}

enum BillStatus {
  PAID
  UNPAID
  OVERDUE
  UPCOMING
  CANCELLED
}

enum RecurringType {
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
  YEARLY
  CUSTOM
}

model CourseReview {
  id        String   @id @default(cuid())
  rating    Int      @default(0)
  comment   String   @db.Text
  courseId  String
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  course    Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([courseId])
  @@index([userId])
}

model Enrollment {
  id        String   @id @default(uuid())
  userId    String
  courseId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  course    Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)

  @@unique([userId, courseId])
  @@index([userId])
  @@index([courseId])
}

model UserCalendarSettings {
  id                  String   @id @default(cuid())
  userId              String   @unique
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  defaultView         String   @default("month")
  firstDayOfWeek      Int      @default(0)
  showWeekNumbers     Boolean  @default(false)
  enableNotifications Boolean  @default(true)
  notificationTime    Int      @default(30)
  timeZone            String   @default("UTC")
  workingHoursStart   String   @default("09:00")
  workingHoursEnd     String   @default("17:00")
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([userId])
}

model Group {
  id          String  @id @default(cuid())
  name        String
  description String? @db.Text
  imageUrl    String?

  // Keep existing fields as optional
  privacy   String?
  rules     String[] @default([])
  tags      String[] @default([])
  isPrivate Boolean  @default(false)

  // Keep both old and new category fields as optional
  category    String? // Keep the old field
  categoryId  String? // Add new field for relation
  categoryRef Category? @relation(fields: [categoryId], references: [id]) // Rename relation to avoid conflict

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  resources     GroupResource[]
  creator       User                @relation("GroupCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  creatorId     String
  members       GroupMember[]
  course        Course?             @relation(fields: [courseId], references: [id])
  courseId      String?
  discussions   GroupDiscussion[]
  events        GroupEvent[]
  notifications GroupNotification[]

  @@index([creatorId])
  @@index([courseId])
  @@index([categoryId])
}

model GroupMember {
  id       String   @id @default(cuid())
  role     String // "admin" | "moderator" | "member"
  status   String // "active" | "pending" | "banned"
  joinedAt DateTime @default(now())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  groupId String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
  @@index([userId])
  @@index([groupId])
}

// Add these models for notifications and search
model GroupNotification {
  id      String  @id @default(cuid())
  type    String // "event", "discussion", "resource", "member"
  title   String
  content String
  isRead  Boolean @default(false)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  groupId String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([groupId])
}

// Add this model to your schema
model GroupDiscussion {
  id        String   @id @default(cuid())
  title     String
  content   String
  createdAt DateTime @default(now())

  groupId String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  authorId String
  author   User   @relation("AuthoredDiscussions", fields: [authorId], references: [id], onDelete: Cascade)

  commentsCount Int @default(0)
  comments      GroupDiscussionComment[]
  likesCount    Int      @default(0)
  likedBy       GroupDiscussionLike[]

  @@index([groupId])
  @@index([authorId])
}

model GroupDiscussionLike {
  id           String          @id @default(cuid())
  discussionId String
  discussion   GroupDiscussion @relation(fields: [discussionId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation("UserLikes", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([discussionId, userId])
  @@index([discussionId])
  @@index([userId])
}

model GroupDiscussionComment {
  id      String @id @default(cuid())
  content String @db.Text

  discussionId String
  discussion   GroupDiscussion @relation(fields: [discussionId], references: [id], onDelete: Cascade)

  authorId String
  author   User   @relation("AuthoredComments", fields: [authorId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([discussionId])
  @@index([authorId])
}

// Add this model for group events
model GroupEvent {
  id           String   @id @default(cuid())
  title        String
  description  String?  @db.Text
  date         DateTime
  startTime    String? // Made optional
  endTime      String? // Made optional
  location     String?
  isOnline     Boolean  @default(false)
  meetingUrl   String?
  maxAttendees Int?
  status       String   @default("upcoming") // upcoming, ongoing, completed, cancelled
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Make both creator and organizer optional to avoid data loss
  creatorId String?
  creator   User?   @relation("EventCreator", fields: [creatorId], references: [id], onDelete: SetNull)

  organizerId String?
  organizer   User?   @relation("OrganizedEvents", fields: [organizerId], references: [id], onDelete: SetNull)

  groupId String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  attendees GroupEventAttendee[]

  @@index([creatorId])
  @@index([organizerId])
  @@index([groupId])
}

model GroupEventAttendee {
  id     String @id @default(cuid())
  status String @default("attending") // attending, maybe, declined

  eventId String
  event   GroupEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation("EventAttendee", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
}

model GroupResource {
  id          String   @id @default(cuid())
  title       String
  description String?  @db.Text
  type        String // "document", "video", "link", "image", "book", "pdf"
  url         String
  fileSize    Int? // For documents and files
  mimeType    String? // For proper file handling
  thumbnail   String? // For videos and images
  createdAt   DateTime @default(now())

  groupId String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  authorId String
  author   User   @relation("AuthoredResources", fields: [authorId], references: [id], onDelete: Cascade)

  @@index([groupId])
  @@index([authorId])
}

model CustomTab {
  id     String @id @default(cuid())
  label  String
  icon   String
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Add these models to your schema
model Notification {
  id        String   @id @default(cuid())
  title     String
  message   String
  type      String   // "info" | "success" | "warning" | "error"
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Message {
  id        String   @id @default(cuid())
  content   String
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  
  // Sender
  senderId  String
  sender    User     @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  
  // Recipient
  recipientId String
  recipient   User     @relation("ReceivedMessages", fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([senderId])
  @@index([recipientId])
}

// Activity model for tracking tasks, plans, and activities
model Activity {
  id            String   @id @default(cuid())
  title         String
  description   String?  @db.Text
  type          String   // "idea" | "mind" | "script" | "subscription" | "billing" | "plan"
  status        String   // "completed" | "in-progress" | "not-started" | "overdue" | "cancelled"
  priority      String   // "low" | "medium" | "high" | "critical"
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  dueDate       DateTime?
  completedDate DateTime?
  progress      Int      @default(0) // 0-100
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  parentId      String?  // For sub-tasks
  tags          String[] @default([])
  metadata      Json?    // Type-specific additional data

  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([dueDate])
}

// Add LoginAttempt model for rate limiting
model LoginAttempt {
  id        String   @id @default(cuid())
  email     String   // We don't use relation to avoid leaking user existence
  ipAddress String
  userAgent String?
  success   Boolean  @default(false)
  createdAt DateTime @default(now())
  
  // Index to query by email and IP for rate limiting
  @@index([email, ipAddress])
  @@index([ipAddress])
  @@index([createdAt])
}

// Add AuthAudit model for security audit trail
model AuthAudit {
  id          String   @id @default(cuid())
  userId      String?  // Optional because some events happen before user is authenticated
  email       String?  // Email associated with the event
  action      String   // Login, Logout, PasswordReset, etc.
  ipAddress   String
  userAgent   String?
  browser     String?
  os          String?
  deviceType  String?
  countryCode String?
  city        String?
  status      String   // Success, Failed, Blocked, etc.
  details     String?  // Additional details about the event
  createdAt   DateTime @default(now())
  
  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@index([ipAddress])
}

// Add ActiveSession model to track user sessions
model ActiveSession {
  id              String   @id @default(cuid())
  userId          String
  sessionToken    String   @unique
  ipAddress       String
  userAgent       String?
  browser         String?
  os              String?
  deviceType      String?
  lastActiveAt    DateTime @default(now())
  expiresAt       DateTime
  isRevoked       Boolean  @default(false)
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([sessionToken])
  @@index([expiresAt])
}

// Add BackupCode model for 2FA recovery
model BackupCode {
  id        String   @id @default(cuid())
  userId    String
  code      String   // Hashed backup code
  isUsed    Boolean  @default(false)
  createdAt DateTime @default(now())
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@unique([userId, code])
}

// Add TOTPSecret model
model TOTPSecret {
  id        String   @id @default(cuid())
  userId    String   @unique
  secret    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
}

// Task model for user's planned tasks with reminders
model Task {
  id          String   @id @default(uuid())
  title       String
  description String?  @db.Text
  startTime   DateTime? // New field for when the task begins
  dueDate     DateTime
  priority    String
  category    String
  completed   Boolean  @default(false)
  
  // Reminder related fields
  hasReminder Boolean  @default(false)
  reminderDate DateTime?
  reminderType String? // email, push, in-app
  reminderSent Boolean  @default(false)
  
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([userId])
  @@index([dueDate])
  @@index([completed])
}
